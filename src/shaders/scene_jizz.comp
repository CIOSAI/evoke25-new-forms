#version 460
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

uniform float u_t;
uniform int F;

layout(binding = 0, r32ui) uniform coherent uimage2D tex_r;
layout(binding = 1, r32ui) uniform coherent uimage2D tex_g;
layout(binding = 2, r32ui) uniform coherent uimage2D tex_b;

const float BEAT_DUR=60./90.;
const float PI=acos(-1.);
const float TAU=PI*2.;

const float pi=acos(-1.);
const float tau=pi*2.;

mat3 xlate2(float n, float m) {return mat3(1,0,0,0,1,0,n,m,1);}
mat3 scale2(float n) {return mat3(n,0,0,0,n,0,0,0,1);}
mat3 rotz(float n) {return mat3(cos(n),-sin(n),0,sin(n),cos(n),0,0,0,1);}
mat2 rot_(float a) {return mat2(cos(a),-sin(a),sin(a),cos(a));}
uint seed_;
uint hashi_( uint x) {
    x ^= x >> 16;
    x *= 0x7feb352dU;
    x ^= x >> 15;
    x *= 0x846ca68bU;
    x ^= x >> 16;
    return x;
}
float hash_f_s_(uint s) {return ( float( hashi_(uint(s)) ) / float( 0xffffffffU ) );}
float hash_f_()  { seed_ = hashi_(seed_);
  return ( float( seed_ ) / float( 0xffffffffU ) );}
vec2 hash_v2_() {return vec2(hash_f_(),hash_f_());}
vec3 hash_v3_() {return vec3(hash_f_(),hash_f_(),hash_f_());}
vec2 sample_disk(){
    vec2 r = hash_v2_();
    return vec2(sin(r.x*TAU),cos(r.x*TAU))*sqrt(r.y);
}

vec2 R;
ivec2 proj(vec3 p){
  // depth of field
  p.xy += sample_disk() * abs(p.z)*0.02;
	
  
  // convert point to ivec2. From 0 to resolution.xy
  ivec2 q = ivec2((p.xy + vec2(R.x/R.y,1)*0.5)*vec2(R.y/R.x,1)*R);
	/*
  if(any(greaterThan(q, ivec2(R))) || any(lessThan(q, ivec2(0)))){
      q = ivec2(-1);
  }
	*/
  return q;
}

float bass_pat[20] = {1.,0.,0.,0.,1., 1.,0.,1.,0.,0., 0.,0.,0.,0.,1., 1.,0.,1.,0.,0.};
float sinease(float n) {
    return sin(-n*PI-PI/2.0)*0.5+0.5;
}
float expease(float n, float deg) {
    return n>0.0?1.0-exp(-n*deg):0.0;
}
vec3 cyclic(vec3 p, float pers, float lacu) {
  vec4 sum = vec4(0);

  for (int i = 0; i ++ < 5;) {
    //p *= rot;
    p.yz *= rot_(4.5);
    p.xy *= rot_(1.5);
    p += sin(p.zxy);
    sum += vec4(cross(cos(p), sin(p.yzx)), 1);
    sum /= pers;
    p *= lacu;
  }


  return sum.xyz / sum.w;
}

void store_pixel(ivec2 px_coord, vec3 col){
  ivec3 quant_col = ivec3(col * 2048);
  imageStore(tex_r, px_coord, ivec4(quant_col.x)); 
  imageStore(tex_g, px_coord, ivec4(quant_col.y)); 
  imageStore(tex_b, px_coord, ivec4(quant_col.z)); 
}

void add_to_pixel(ivec2 px_coord, vec3 col){
  ivec3 quant_col = ivec3(col * 2048);
  imageAtomicAdd(tex_r, px_coord, quant_col.x);
  imageAtomicAdd(tex_g, px_coord, quant_col.y);
  imageAtomicAdd(tex_b, px_coord, quant_col.z);
}

vec3 read_pixel(ivec2 px_coord){
  return vec3(
    imageLoad(tex_r,px_coord).x,
    imageLoad(tex_g,px_coord).x,
    imageLoad(tex_b,px_coord).x
  )/2048.;
}

void tree(ivec2 image_res, int id) {
    seed_ = uint(id) + 125125u + uint(F);
    
    float brancherMusicTime = max(0., u_t/BEAT_DUR-20.*1.);
    float brancher = 0.;
    for (int i=0; i<20; i++) {brancher += bass_pat[i];}
    brancher *= floor(brancherMusicTime/5.);
    for (int i=0; i<20; i++) {
      int curr = int(mod(floor(brancherMusicTime*4.),5.*4.));
      if (i>curr) {break;}
      brancher += bass_pat[i]*expease(float(curr-i)+fract(brancherMusicTime*4.),3.);
    }
    brancher *= .25;
    brancher += u_t*.4*step(1., u_t/BEAT_DUR/20.);
    vec2 walk=vec2(1,0);
    for(int i=0; i<image_res.x/16; i++){
	    walk.x-=16.*(2.+hash_f_()*.1)/float(image_res.x);
      
      int split = 7;
      
      float timeOff = hash_f_s_(id%split);
      float t = timeOff+brancher;

      float y = 0.;
      for(int j=0; j<4; j++) {
        float cutoff = mix(hash_f_s_(id%split+j*4+1+int(t)),
                           hash_f_s_(id%split+j*4+2+int(t)),sinease(fract(t)));
        cutoff -= float(j)*.4+timeOff*.8-.3;
        float shift = mix(hash_f_s_(id%split+j*4+3+int(t)),
                          hash_f_s_(id%split+j*4+4+int(t)),sinease(fract(t)));
        shift=shift*2.-1.; shift *= smoothstep(0.,1.,u_t/BEAT_DUR/20.);
        y=y+smoothstep(0.,1.,(cutoff-walk.x)*4.)*shift*.2;
      }
      
      vec3 p = vec3(vec2(walk.x,y), pow(sin(walk.x*1.8-timeOff*18.-u_t*.9)*.5+.5,1999.));
      if (hash_f_()<smoothstep(.1,0.,u_t/BEAT_DUR/20.)) {return;}
      if (hash_f_()>smoothstep(3.+7.25/8.,3.+6./8.,u_t/BEAT_DUR/20.)) {return;}
      add_to_pixel(proj(vec3(p.xy*rot_(smoothstep(4.,2.,u_t/BEAT_DUR/20.)*PI/2.),p.z)),vec3(1));
    }
}

void voronoi(ivec2 image_res, int id) {
    seed_ = uint(id) + 125125u + uint(F);

    vec3 shift = vec3(1)*u_t*.3;
    vec3 p = hash_v3_()*2.-1.;
    float div = 8.;
    vec3 ip = floor(p*div+shift),
         fp = fract(p*div+shift);
    vec3 cent = cyclic(ip*9.+u_t*.1,1.,1.)*.5;
    vec3 q = (fp*2.-1.)*2.;

    for (float x=-1.; x<1.5; x+=1.) {
    for (float y=-1.; y<1.5; y+=1.) {
    for (float z=-1.; z<1.5; z+=1.) {
      if(abs(x)+abs(y)+abs(z)<.0015) continue;
      vec3 nb = vec3(x,y,z);
      vec3 nbcent = cyclic((ip+nb)*9.+u_t*.1,1.,1.)*.5;
      vec3 a = (nb+nbcent-cent)/2.;
      float ang = acos(dot(q,a)/(length(q)*length(a)));
      if(abs(ang)>pi/2.) continue;
      q = normalize(q)*min(length(q),length(a)/cos(ang)); 
    }
    }
    }

    p = (ip+.5+cent+q-shift)/div;
    p.xy*=vec2(3.,4.)*.5;
    p.zx*=rot_(.3);
    p.yz*=rot_(.7);
    add_to_pixel(proj(vec3(p.xy*rot_(smoothstep(4.,2.,u_t/BEAT_DUR/20.)*PI/2.),p.z)),vec3(exp(-abs(p.z)*110.-7.*smoothstep(4.,1.,u_t/BEAT_DUR/20.))));
}

void font(uint id, uint ch, mat3 trans) {
  vec2[5] strokes = {vec2(1,-1),vec2(1,0),vec2(1,1),vec2(0,1),vec2(-1,1)};
  seed_ = ch;
  mat2 flip = mat2(sign(hash_f_()-.5),0,0,sign(hash_f_()-.5));
  uint[3] choose = {hashi_(ch)%6, hashi_(ch+1)%6, hashi_(ch+2)%6};
  int[3] bend = {int(hashi_(ch+6)%3)-1, int(hashi_(ch+7)%3)-1, int(hashi_(ch+8)%3)-1};
  int drewStroke = 3;
  float circProb = .2;
  for (int i=0; i<3; i++) {
    if (choose[i]>=5) {
      drewStroke--;
    }
  }
  if (drewStroke<=0) {
    choose[0] = hashi_(ch+3)%6;
    choose[1] = hashi_(ch+4)%6;
    choose[2] = hashi_(ch+5)%5;
    circProb += .7;
  }
  bool drawCirc = hash_f_()<circProb;

  seed_ = id;
  float perc = hash_f_();
  uint toDraw = hashi_(seed_+1)%(drawCirc?4:3);
  vec2 q = vec2(0);
  if (toDraw>=3) {
    q = vec2(cos(perc*tau),sin(perc*tau));
  }
  else {
    uint strokeId = choose[toDraw];
    float bendCoeff = float(bend[toDraw]);
    if (strokeId>=5) {return;}
    vec2 from = flip*vec2(-1);
    vec2 to = flip*strokes[strokeId];
    vec2 orth = mat2(0,-1,1,0)*normalize(to-from);
    q = mix(from, to, perc)+orth*bendCoeff*cos(perc*pi-pi/2.)*.3;
  }

  add_to_pixel(proj(vec3((trans*vec3(q,1)).xy,.0)), vec3(1));
}

void title(ivec2 image_res, int id) {
  seed_ = uint(id) + 125125u + uint(F);

  font(uint(id), 10, scale2(.1)*xlate2(-1.5*3.,0.));
  font(uint(id), 3, scale2(.1)*xlate2(-.5*3.,0.));
  font(uint(id), 17, scale2(.1)*xlate2(0.5*3.,0.));
  font(uint(id), 12, scale2(.1)*xlate2(1.5*3.,0.));
}

void bacteria(ivec2 image_res, int id) {
  seed_ = uint(id) + 125125u + uint(F);
  float smth = smoothstep(5.5,5.+6./8.,u_t/BEAT_DUR/20.);
  float centeringCoeff = mix(10.,1.,smth);
  float repelCoeff = 1.;
  float zoom = mix(3.,1.2,smth);
  int animateAgents = int(mix(1.,6.,max(0.,smth-hash_f_()*.1*(1.-smth))));

  float mt = u_t/BEAT_DUR;
    
  const int agents = 8;
  vec4 ps[agents];
  for (int i=0; i<agents; i++) {
    if (i>=animateAgents) break;
    seed_ = 23924u+uint(i);

    float s = float(i)+u_t*.1;

    ps[i].xyz = cyclic(vec3(s), 1., 1.)*float(animateAgents) *.08;
    ps[i].w = mix(.1,.13,hash_f_());
  }
  for (int itr=0; itr<6; itr++) {
    for (int i=0; i<agents*agents; i++) {
      if (i/agents>=animateAgents||i%agents>=animateAgents) continue;
      if (i/agents==i%agents) continue;
      vec4 me = ps[i/agents];
      vec4 nb = ps[i%agents];

      vec3 d = me.xyz-nb.xyz;
      float f = (me.w+nb.w+.15)-length(d);
      f *= exp(abs(f)*1.2)-1.;
      ps[i/agents].xyz += normalize(d)*f*repelCoeff;
      ps[i/agents].xyz -= normalize(ps[i/agents].xyz)*pow(length(ps[i/agents].xyz)*1.,3.)*centeringCoeff;
    }
  }
  for (int i=0; i<agents; i++) {
    if (i>=animateAgents) break;
    seed_ = uint(id) + 125325u + uint(F);

    vec3 cent = ps[i].xyz;
    float rad = ps[i].w;
    vec3 off = normalize(hash_v3_()*2.-1.);
    off *= 1.+(cyclic(off+cent*8.+u_t*.6, 1., 8.))*.15;
    vec3 p = cent+off*rad;
    p.xz *= rot_(u_t);
    p.zy *= rot_(u_t*.7);
    add_to_pixel(proj(p*zoom),vec3(.02));
  }
}

void dna(ivec2 image_res, int id) {
  seed_ = uint(id) + 125125u + uint(F);

  float height = hash_f_()*2.-1.;
  height *= 4.;
  float phase = step(.5, hash_f_())*pi;
  float span = hash_f_()*.3;
  vec3 p = vec3(cos(height*3.+phase-u_t),height+span,sin(height*3.+phase-u_t));

  add_to_pixel(proj(p*.15-vec3(.65,0,0)), vec3(.1));
}

void analysis(ivec2 image_res, int id) {
  seed_ = uint(id) + 125125u + uint(F);

  vec2 dim = vec2(.4,.3);
  vec2 pos = vec2(.55,-.3);

  float yaxis = step(dim.x/(dim.x+dim.y), hash_f_());
  float side = sign(hash_f_()-.5);

  vec2 p = mix(vec2(dim.x*(hash_f_()-.5), side*dim.y/2.), vec2(side*dim.x/2., dim.y*(hash_f_()-.5)), yaxis);

  float distSeed_ = p.x+p.y*.2 -u_t*22.;
  p += .1*vec2(.4,.8)*cyclic(vec3(floor(distSeed_*4.)+tanh((fract(distSeed_*4.)*2.-1.)*8.)*.5+.5),1.,2.).x*step(5.5,u_t/BEAT_DUR/20.);

  add_to_pixel(proj(vec3(p+pos,0)), vec3(1));

  add_to_pixel(proj(vec3((pos-vec2(dim.x/2.,-dim.y/2.))*hash_f_(),0)), vec3(1));

  vec2 tx = hash_v2_()*dim*8.;
  vec2 itx = floor(tx);
  float distSeed_2 = itx.x+itx.y*.2 -u_t*22.;
  vec2 dist = vec2(.4,.8)*cyclic(vec3(floor(distSeed_2*4.)+tanh((fract(distSeed_2*4.)*2.-1.)*8.)*.5+.5),1.,2.).x*step(5.5,u_t/BEAT_DUR/20.);
  font(id, uint(min(itx.y*4.+itx.x, (u_t/BEAT_DUR-4.5*20.)*2.)),
    xlate2(pos.x+(itx.x/4.-.375)*.3+dist.x*.03,pos.y+(itx.y/4.-.275)*.3+dist.y*.03)*scale2(.02)
    );
}

void network(ivec2 image_res, int id) {
  seed_ = uint(id) + 125125u + uint(F);

  vec2 dim = vec2(.1,.05);
  vec2 pos = floor(hash_v2_()*vec2(16.,8.));
  vec2 cellId = pos;
  pos = pos/vec2(4.,8.) -vec2(1.,.425);

  vec2 p=vec2(0);
  if (cyclic(vec3(cellId, u_t-pow(hash_f_(),55.)*.2),1.,1.).x>0.) {
    float yaxis = step(dim.x/(dim.x+dim.y), hash_f_());
    float side = sign(hash_f_()-.5);
    p = mix(vec2(dim.x*(hash_f_()-.5), side*dim.y/2.), vec2(side*dim.x/2., dim.y*(hash_f_()-.5)), yaxis);
  }
  else {
    p = (hash_v2_()*2.-1.)*vec2(dim.x, dim.y)/2.;
  }
  p.x += p.y*.2;

  add_to_pixel(proj(vec3(p+pos,0)), vec3(.1));

  float line = step(.5, hash_f_());
  vec2 nb = vec2(1., -line)/vec2(8.,8.);

  float gate = pow(1.-clamp((u_t/BEAT_DUR/20.-5.)*2.,0.,1.),.6);

  for(int y=7; y>=0; y--) {
    if(y<int(cellId.y)) {break;}
    for(int x=0; x<16; x++) {
      if(int(cellId.y)-y<x-int(cellId.x)) {break;}

      if(gate*2.-1.<cyclic(
        vec3(float(x), float(y), line)+
        u_t-pow(hash_f_(),15.)*.05, 
        1., 1.).x) {return;}
    }
  }

  add_to_pixel(proj(vec3(pos+nb*hash_f_()+vec2(.5,0)/vec2(8.,8.),0)), vec3(1));
}

float box(vec2 p) {
  vec2 q = abs(p);
  return max(q.x,q.y);
}

float heart(vec2 p) {
  vec2 q = abs(p);
  return mix(box(vec2(p.x-p.y,p.x+p.y))/sqrt(2.), length(q-(q.x*q.x+q.y*q.y)/(2.*(q.x+q.y))), step(0.,p.y)) - .5;
}

float scrn(vec2 p) {
  float circ = abs(length(p)-.8)-.05;
  float leye = length(p+vec2(.31,-.2))-.12;
  float reye = mix(length(p-vec2(.31,.2))-.12, box(p*vec2(.5,1.8)-vec2(.15,.3))-.1, step(0.,sin(u_t*8.)));
  float eye = min(leye, reye);
  float mouth = max(step(0.,p.y), abs(length(p)-.45)-.05);
  float smile = min(min(circ, mouth), eye);

  vec2 p2 = p+vec2(0,.1);
  float heart = heart(p2);

  float text = float[](0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,
                       0.,0.,1.,1.,1.,0.,1.,1.,1.,1.,0.,0.,1.,1.,0.,0.,
                       0.,1.,0.,0.,0.,0.,0.,.7,.1,0.,0.,1.,0.,0.,1.,0.,
                       0.,1.,0.,0.,0.,0.,0.,.7,.1,0.,0.,1.,0.,0.,1.,0.,
                       0.,1.,0.,0.,0.,0.,0.,.7,.1,0.,0.,1.,0.,0.,1.,0.,
                       0.,1.,0.,0.,0.,0.,0.,.7,.1,0.,0.,1.,0.,0.,1.,0.,
                       0.,0.,1.,1.,1.,0.,1.,1.,1.,1.,0.,0.,1.,2.,0.,0.,
                       0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,
                       0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,
                       0.,0.,1.,1.,1.,0.,0.,1.,1.,0.,0.,1.,1.,1.,1.,0.,
                       0.,1.,0.,0.,0.,0.,1.,0.,0.,1.,0.,0.,.7,.1,0.,0.,
                       0.,0.,1.,1.,0.,0.,1.,0.,0.,1.,0.,0.,.7,.1,0.,0.,
                       0.,0.,0.,0.,1.,0.,1.,1.,1.,1.,0.,0.,.7,.1,0.,0.,
                       0.,0.,0.,0.,1.,0.,1.,0.,0.,1.,0.,0.,.7,.1,0.,0.,
                       0.,1.,1.,1.,0.,0.,1.,0.,0.,1.,0.,1.,1.,1.,1.,0.,
                       0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.
  )[int((-p.y*.5+.5)*16.)*16+int((p.x*.5+.5)*16.)];

  float t = u_t*.2;
  float o;
  if (fract(t)<0.33) {
    o = pow(smile,.3);
  }
  else if (fract(t)<0.66) {
    o = pow(heart,.3);
  }
  else {
    o = text;
  }

  return clamp(o, 0., 1.);
}

void ui(ivec2 image_res, int id) {
  seed_ = uint(id) + 125125u + uint(u_t);

  vec3 p = vec3(0);
  vec3 n = cyclic(vec3(hashi_(seed_)),1.,1.);

  for (int i=0; i<24; i++) {
    if (float(i-12)/12.>n.x) {break;}
    float prog = hash_f_s_(i+seed_*24);
    n.yz = cyclic(n, 1., 2.).xy;
    vec2 off = floor((n.yz+1.)*1.5)-1.;
    off = normalize(off);
    float toff = 1.-sinease(clamp(u_t/BEAT_DUR/20.-6.,0.,1.));
    vec3 q = mix(p, p+vec3(off,0), prog);
    q.x += toff*4.;
    q.yz *= rot_(.6+toff);
    q.xy *= rot_(.2+toff);
    store_pixel(proj(q*(1.-toff)),vec3(.5+float(i)/24.));
    p.xy+=off;
  }

}

void ui2(ivec2 image_res, int id) {
    seed_ = uint(id) + 125125u + uint(u_t);

    float rand = hash_f_();
    uint agent = seed_%4;
    vec2 silly = vec2(floor(rand*16.), fract(rand*16.));
    vec2 p = vec2(rand*2.-1., .5);
    float prev = p.y;
    for(float x=0.; x<silly.x; x++) {
      prev = p.y;
      p.y -= step(.1, cyclic(vec3(float(agent)*664.475,x*123.984,u_t*.2+(hash_f_s_(seed_)*2.-1.)*.1-p.x*.2),1.,1.).x) * 2./16.;
    }
    // p.y = mix(prev, p.y, min(1.,max(0.,(silly.y-.5)*2.+.5)));
    p.y = mix(prev, p.y, sinease(silly.y));
    p -= float(agent)*.03;
    
    add_to_pixel(proj(vec3(p,0)),vec3(1));

    vec3 q = hash_v3_()*2.-1.;
    int lock = int(hash_f_()*3.);
    if (lock<.5) {
      q.xy = sign(q.xy);
    }
    else if (lock<1.5) {
      q.yz = sign(q.yz);
    }
    else {
      q.xz = sign(q.xz);
    }

    float phase = hash_f_s_(seed_%3);
    float cubeT = u_t+phase;
    q.zx *= rot_(cubeT);
    q.yz *= rot_(cubeT*.7);

    add_to_pixel(proj(q*.15-vec3(.55,.15,phase)),vec3(.01));

    vec2 r = hash_v2_()*2.-1.;
    float div = 8.;

    float val = scrn(floor(r*div)/div+.5/div);
    r = mix(floor(r*div)/div, (floor(r*div)+1.)/div, fract(r*div)*.7+.15);
    // val = pow(val, .254545);

    store_pixel(proj(vec3(r*.15+vec2(.7,.3),0)),vec3(val));
}

float rod(vec2 p, float len) {
  float fun = p.x;
  p.x = abs(p.x);
  p.x-=len/2.;
  return (p.x>0.?max(abs(p.x),abs(p.y)):abs(p.y));
}

float arrow(vec2 p, float len) {
  float stem = rod(p-vec2(len/2.+.2,0), len);
  float head = min(rod(p*rot_(tau/8.)-vec2(.5,0), 1.), rod(p*rot_(-tau/8.)-vec2(.5,0), 1.));
  return min(stem, head);
}

float crawl(vec2 p) {
  return min(arrow(vec2(-p.x+1.5,p.y)*1.25,1.5)-.3,
  heart(p+vec2(1.0,0.)));
}

void hatch(ivec2 image_res, int id) {
  seed_ = uint(id) + 125125u;// + uint(u_t);
  
  float prog = hash_f_();
  // seed_ = seed_%2048 + hashi_(uint(u_t*88.));
  vec2 sta = cyclic(vec3(float(seed_%4096), u_t*.2, 0.), 3., 1.1).xy;
  vec2 end = cyclic(vec3(float(seed_%4096), u_t*.2, 1.), 1., 1.1).xy; end = sta+end*.3;
  float val = 1.;
  vec2 rd = normalize(end-sta);
  float ld=0., td=0.;
  float acc = 0.;
  float outside = 1.;
  for(int i=0; i<128; i++) {
    vec2 po = sta+rd*td;
    ld = crawl(po*2.+vec2(3.-(u_t/BEAT_DUR/20.-10.)*2.,0.));
    ld *= outside;
    ld = min(ld, length(po-end));

    if (dot(po-sta, rd)>0. && abs(length(po-end))<.0015) {
      break;
    }
    if (ld<.0015) {
      outside = -outside;
      td += 3*.0015;
      continue;
    }
    if (outside<0.) {
      acc += ld;
    }
    td += ld;
  }

  add_to_pixel(proj(vec3(mix(sta, end, prog), prog)), vec3(pow(1.-acc/length(sta-end), 12.))*.02);
}

void textGlobe(ivec2 image_res, int id) {
  float first = smoothstep(10.,10.5,u_t/BEAT_DUR/20.);
  float scnd = smoothstep(10.5,11.5,u_t/BEAT_DUR/20.);

  seed_ = uint(id) + 1259u;
  int amt = 2+int(first*14.);
  
  float t = floor(u_t/BEAT_DUR)+expease(fract(u_t/BEAT_DUR), 2.5);
  vec3 end = cyclic(vec3(float(seed_%amt)*.25, t*.2+4., 0.), 1., 1.);
  end=normalize(end)*.8;
  end.z+=2.;
  vec3 next = cyclic(vec3(float((seed_+1)%amt)*.25, t*.2+4., 0.), 1., 1.);
  next=normalize(next)*.8;
  next.z+=2.;
  uint ch = seed_%amt;

  vec2 p = end.xy/end.z;

  add_to_pixel(proj(vec3(mix(vec2(0), p, hash_f_()), 0.)), vec3(.001));
  add_to_pixel(proj(vec3(mix(next.xy/next.z, p, hash_f_()), 0.)), vec3(.001));

  vec3 ball = normalize(hash_v3_()-.5);
  ball += scnd*cyclic(ball, 1., 1.2);
  ball += scnd*cyclic(ball, 1., 1.2);
  ball += scnd*cyclic(ball, 1., 1.2);
  ball += scnd*cyclic(ball, 1., 1.2);
  ball += scnd*cyclic(ball, 1., 1.2);
  vec2 surface = vec2(atan(ball.x, -ball.z), atan(ball.y, -ball.z));
  surface.x = fract(surface.x/tau-u_t*.2)*tau;
  float br = step(0., crawl(surface-vec2(pi,0)));
  add_to_pixel(proj(ball*.4+vec3(0,0,2)), vec3(.011*br));

  font(id, ch, xlate2(p.x+(hash_f_()*2.-1.)*.002,p.y+(hash_f_()*2.-1.)*.002)*scale2(.04/end.z));
}

void bg(ivec2 image_res, int id) {
  seed_ = uint(id) + 125125u;
  
  float prog = hash_f_();
  vec2 sta = cyclic(vec3(float(seed_%4096), u_t*.2, 0.), 3., 1.1).xy;
  vec2 end = cyclic(vec3(float(seed_%4096), u_t*.2, 1.), 1., 1.1).xy; end = sta+end*.6;

  add_to_pixel(proj(vec3(mix(sta, end, prog), prog)), vec3(.0007));
}

void cornerText(ivec2 image_res, int id) {
  seed_ = uint(id) + 2225u;

  int amt = 4;
  uint toff = uint(5.*u_t/BEAT_DUR);
  uint ch = seed_%amt + hashi_(toff);
  vec2 dim = vec2(.7,.3);
  vec2 thick = (hash_v2_()*2.-1.)*.005;
  vec2 corner = vec2(sign(hash_f_s_(ch)-.5), sign(hash_f_s_(ch+99)-.5));
  float vel = hash_f_s_(ch+toff);

  if (hash_f_s_(seed_)>pow(20000., vel-1.)) {return;}
  font(hashi_(ch)+id, ch, xlate2(dim.x*corner.x,dim.y*corner.y)*xlate2(thick.x, thick.y)*scale2(.1));
}


void main() {
		R = vec2(imageSize(tex_g).xy);
    ivec2 image_res = ivec2(imageSize(tex_b));

    int id = int(gl_GlobalInvocationID.x)+int(gl_GlobalInvocationID.y)*image_res.x;

		seed_ = uint(id +1245124);
    
    if (u_t/BEAT_DUR/20.<3.+7.25/8.) {
      bg(image_res, id);
      tree(image_res, id);
      voronoi(image_res, id);
    }
    else if (u_t/BEAT_DUR/20.<4.) {
      bg(image_res, id);
      title(image_res, id);
      voronoi(image_res, id);
    }
    else if (u_t/BEAT_DUR/20.<6.){
      bg(image_res, id);
      if (u_t/BEAT_DUR/20.>5. && u_t/BEAT_DUR/20.<5.5) {
        network(image_res, id);
      }
      else {
        bacteria(image_res, id);
        if (u_t/BEAT_DUR/20.>4.5) {
          dna(image_res, id);
          analysis(image_res, id);
        }
      }
    }
    else if (u_t/BEAT_DUR/20.<7.){
      bg(image_res, id);
      ui(image_res, id);
      cornerText(image_res, id);
    }
    else if (u_t/BEAT_DUR/20.<8.73){
      bg(image_res, id);
      ui(image_res, id);
    }
    else {
      bg(image_res, id);
      if (u_t/BEAT_DUR/20.<11.) {
        textGlobe(image_res, id);
        cornerText(image_res, id);
      }
      else if (u_t/BEAT_DUR/20.<12.) {
        hatch(image_res, id);
      }
    }
}

